<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>SLAM AR — Ground Plane</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&family=Outfit:wght@300;400;600;700;800&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0a0f;--surface:#12121a;--border:#1e1e2e;--text:#e8e8f0;--dim:#6b6b80;--accent:#00e5a0;--accent2:#00b8ff;--warn:#ff6b35;--danger:#ff3366;--glow:0 0 20px rgba(0,229,160,0.3);--radius:12px}
html,body{width:100%;height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:'Outfit',sans-serif;touch-action:none;-webkit-touch-callout:none;user-select:none}
#app{width:100%;height:100%;position:relative}
#startScreen{position:absolute;inset:0;z-index:100;display:flex;flex-direction:column;align-items:center;justify-content:center;background:var(--bg);gap:20px;transition:opacity .5s,transform .5s}
#startScreen.hidden{opacity:0;pointer-events:none;transform:scale(1.05)}
.logo{font-size:clamp(2rem,6vw,3.2rem);font-weight:800;letter-spacing:-2px;background:linear-gradient(135deg,var(--accent),var(--accent2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.sub{color:var(--dim);font-size:.9rem;font-weight:300;max-width:320px;text-align:center;line-height:1.5}
.tags{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
.tag{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:8px 14px;font-size:.75rem;color:var(--dim)}
#startBtn{margin-top:8px;padding:14px 44px;border:none;border-radius:60px;background:linear-gradient(135deg,var(--accent),#00c8e0);color:#0a0a0f;font-family:'Outfit',sans-serif;font-size:1rem;font-weight:700;cursor:pointer;box-shadow:var(--glow)}
#videoEl{display:none}
#arCanvas{position:absolute;inset:0;width:100%;height:100%}
.hud{position:absolute;z-index:10;pointer-events:none}.hud>*{pointer-events:auto}
#topBar{top:0;left:0;right:0;padding:env(safe-area-inset-top,12px) 12px 0 12px;display:flex;justify-content:space-between;align-items:flex-start}
#pill{display:flex;align-items:center;gap:7px;background:rgba(10,10,15,.75);backdrop-filter:blur(12px);border:1px solid var(--border);border-radius:60px;padding:6px 13px;font-family:'JetBrains Mono',monospace;font-size:.7rem;transition:border-color .4s,box-shadow .4s}
#pill.ok{border-color:var(--accent);box-shadow:var(--glow)}
#dot{width:7px;height:7px;border-radius:50%;background:var(--warn);transition:background .4s}
#pill.ok #dot{background:var(--accent);box-shadow:0 0 6px var(--accent)}
#stxt{color:var(--dim);transition:color .3s}
#pill.ok #stxt{color:var(--accent)}
#fps{background:rgba(10,10,15,.75);backdrop-filter:blur(12px);border:1px solid var(--border);border-radius:var(--radius);padding:4px 9px;font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--dim)}
#bottomBar{bottom:0;left:0;right:0;padding:0 12px env(safe-area-inset-bottom,12px) 12px;display:flex;justify-content:center;gap:8px}
.btn{padding:8px 16px;border:1px solid var(--border);border-radius:60px;background:rgba(10,10,15,.75);backdrop-filter:blur(12px);color:var(--text);font-family:'Outfit',sans-serif;font-size:.75rem;font-weight:500;cursor:pointer;-webkit-tap-highlight-color:transparent}
.btn:active{transform:scale(.95)}.btn.on{border-color:var(--accent);color:var(--accent)}.btn.red{border-color:var(--danger);color:var(--danger)}
#reticle{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:44px;height:44px;z-index:5;pointer-events:none;opacity:0;transition:opacity .4s}
#reticle.show{opacity:1}
#reticle svg{width:100%;height:100%}
#toast{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(10,10,15,.82);backdrop-filter:blur(12px);border:1px solid var(--accent);border-radius:var(--radius);padding:8px 16px;font-size:.75rem;color:var(--accent);opacity:0;transition:all .4s;pointer-events:none;z-index:10;box-shadow:var(--glow);white-space:nowrap}
#toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}
#scaleHint{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(10,10,15,.8);backdrop-filter:blur(12px);border:1px solid var(--accent2);border-radius:var(--radius);padding:6px 13px;font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--accent2);opacity:0;transition:opacity .3s;pointer-events:none;z-index:11;white-space:nowrap}
#scaleHint.show{opacity:1}
#dbg{position:absolute;top:48px;left:12px;z-index:15;background:rgba(10,10,15,.88);backdrop-filter:blur(12px);border:1px solid var(--border);border-radius:var(--radius);padding:10px;font-family:'JetBrains Mono',monospace;font-size:.58rem;color:var(--dim);line-height:1.7;min-width:180px;display:none}
#dbg.show{display:block}#dbg b{color:var(--accent);font-weight:400}
#objBadge{position:absolute;top:48px;right:12px;z-index:10;background:rgba(10,10,15,.75);backdrop-filter:blur(12px);border:1px solid var(--border);border-radius:var(--radius);padding:4px 9px;font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--dim);display:none}
@media(max-width:480px){.btn{padding:7px 12px;font-size:.7rem}}
</style>
</head>
<body>
<div id="app">
  <div id="startScreen">
    <div class="logo">SLAM AR</div>
    <div class="sub">Realidade Aumentada no navegador com detecção de plano — sem ARKit/ARCore.</div>
    <div class="tags"><div class="tag">Sensor Fusion</div><div class="tag">Optical Flow</div><div class="tag">Ground Plane</div><div class="tag">3D Cubes</div></div>
    <button id="startBtn">Iniciar AR</button>
  </div>
  <video id="videoEl" playsinline autoplay muted></video>
  <canvas id="arCanvas"></canvas>
  <div id="reticle"><svg viewBox="0 0 44 44" fill="none" stroke="#00e5a0" stroke-width="1.5"><circle cx="22" cy="22" r="16" opacity=".3"/><circle cx="22" cy="22" r="3"/><line x1="22" y1="2" x2="22" y2="10" opacity=".5"/><line x1="22" y1="34" x2="22" y2="42" opacity=".5"/><line x1="2" y1="22" x2="10" y2="22" opacity=".5"/><line x1="34" y1="22" x2="42" y2="22" opacity=".5"/></svg></div>
  <div class="hud" id="topBar"><div id="pill"><div id="dot"></div><span id="stxt">Inicializando...</span></div><div id="fps">-- FPS</div></div>
  <div id="objBadge">Cubos: <span id="objN">0</span></div>
  <div id="dbg">Feats: <b id="dF">0</b><br>Track: <b id="dT">0</b><br>Cam: <b id="dC">0,0,0</b><br>Plane: <b id="dP">--</b><br>PlnY: <b id="dPY">--</b><br>Gyro: <b id="dG">--</b><br>Ms: <b id="dM">--</b></div>
  <div id="toast"></div>
  <div id="scaleHint"></div>
  <div class="hud" id="bottomBar">
    <button class="btn" id="bDbg">Debug</button>
    <button class="btn" id="bCal">Calibrar</button>
    <button class="btn red" id="bRst">Reset</button>
  </div>
</div>
<script>
/*
 * SLAM AR v3 — Sensor-Fusion + Visual Odometry
 *
 * Architecture like 8th Wall / WebXR:
 * - PRIMARY: Device gyroscope/accelerometer for camera orientation
 * - SECONDARY: Optical flow for translational refinement
 * - GROUND PLANE: Fixed at a real-world height (1.3m below camera),
 *   projected using the sensor-derived camera matrix
 * - OBJECTS: Placed in world-space coordinates on the ground plane,
 *   projected through a proper perspective camera model
 *
 * This gives stable, drift-free AR that works immediately when
 * a device with sensors is available, with visual tracking as fallback.
 */

const C = {
  // Visual tracking
  harrisK:.04, harrisTh:5000, maxFeat:80, minFeatD:12,
  nccPatch:7, nccRadius:12, nccTh:.5,
  pw:160, ph:120, focal:200,
  slamEvery:3,
  // World
  cameraHeight: 1.3,   // Meters above ground (approx phone held height)
  groundY: 0,          // Ground is at world Y=0
  worldScale: 1.0,     // World units to meters
  // Rendering
  cubeWorldSize: 0.06, // 6cm cube in world units — physically small
  maxObj: 20,
  // Sensor
  gyroSmooth: 0.15,    // Complementary filter alpha for visual vs gyro
  uiMs: 200,
};

// ========== IMAGE PROCESSING ==========
class ImgProc {
  constructor(w,h){
    this.w=w;this.h=h;const n=w*h;
    this.A=new Uint8Array(n);this.B=new Uint8Array(n);
    this.cur=this.A;this.prev=this.B;
    this.gx=new Int16Array(n);this.gy=new Int16Array(n);
    this.n=0;
  }
  capture(rgba){
    const t=this.prev;this.prev=this.cur;this.cur=t;
    const g=this.cur,n=this.w*this.h;
    for(let i=0;i<n;i++){const j=i<<2;g[i]=(rgba[j]*77+rgba[j+1]*150+rgba[j+2]*29)>>8;}
    this.n++;
  }
  grads(){
    const g=this.cur,w=this.w,h=this.h,gx=this.gx,gy=this.gy;
    for(let y=1;y<h-1;y++){const r=y*w;for(let x=1;x<w-1;x++){const i=r+x;gx[i]=g[i+1]-g[i-1];gy[i]=g[i+w]-g[i-w];}}
  }
}

// ========== HARRIS ==========
class Harris {
  constructor(ip){this.ip=ip;this.R=new Float32Array(ip.w*ip.h);}
  detect(){
    const{w,h}=this.ip,gx=this.ip.gx,gy=this.ip.gy,R=this.R,k=C.harrisK;
    R.fill(0);
    for(let y=2;y<h-2;y++)for(let x=2;x<w-2;x++){
      let sxx=0,syy=0,sxy=0;
      for(let dy=-1;dy<=1;dy++){const ri=(y+dy)*w;for(let dx=-1;dx<=1;dx++){const i=ri+x+dx,ix=gx[i],iy=gy[i];sxx+=ix*ix;syy+=iy*iy;sxy+=ix*iy;}}
      R[y*w+x]=sxx*syy-sxy*sxy-k*(sxx+syy)*(sxx+syy);
    }
    const th=C.harrisTh,cands=[];
    for(let y=3;y<h-3;y++)for(let x=3;x<w-3;x++){
      const i=y*w+x,v=R[i];if(v<th)continue;
      if(R[i-1]>=v||R[i+1]>=v||R[i-w]>=v||R[i+w]>=v||R[i-w-1]>=v||R[i-w+1]>=v||R[i+w-1]>=v||R[i+w+1]>=v)continue;
      cands.push({x,y,s:v});
    }
    cands.sort((a,b)=>b.s-a.s);
    const f=[],md2=C.minFeatD*C.minFeatD;
    for(let i=0;i<cands.length&&f.length<C.maxFeat;i++){
      const c=cands[i];let ok=1;
      for(let j=0;j<f.length;j++){const dx=c.x-f[j].x,dy=c.y-f[j].y;if(dx*dx+dy*dy<md2){ok=0;break;}}
      if(ok)f.push(c);
    }
    return f;
  }
}

// ========== NCC FLOW ==========
class Flow {
  constructor(ip){this.ip=ip;}
  track(pf){
    const prev=this.ip.prev,curr=this.ip.cur,w=this.ip.w,h=this.ip.h;
    const hl=(C.nccPatch-1)>>1,sr=C.nccRadius,pN=C.nccPatch*C.nccPatch,tracked=[];
    for(let fi=0;fi<pf.length;fi++){
      const f=pf[fi],px=f.x|0,py=f.y|0;
      if(px-hl<1||px+hl>=w-1||py-hl<1||py+hl>=h-1)continue;
      let rs=0;for(let dy=-hl;dy<=hl;dy++){const r=(py+dy)*w;for(let dx=-hl;dx<=hl;dx++)rs+=prev[r+px+dx];}
      const rm=rs/pN;let rv=0;
      for(let dy=-hl;dy<=hl;dy++){const r=(py+dy)*w;for(let dx=-hl;dx<=hl;dx++){const v=prev[r+px+dx]-rm;rv+=v*v;}}
      const rd=Math.sqrt(rv/pN);if(rd<3)continue;
      const x0=Math.max(hl+1,px-sr),x1=Math.min(w-hl-2,px+sr),y0=Math.max(hl+1,py-sr),y1=Math.min(h-hl-2,py+sr);
      let bn=-1,bx=px,by=py;
      for(let cy=y0;cy<=y1;cy+=2)for(let cx=x0;cx<=x1;cx+=2){
        let s=0;for(let dy=-hl;dy<=hl;dy++){const r=(cy+dy)*w;for(let dx=-hl;dx<=hl;dx++)s+=curr[r+cx+dx];}
        const m=s/pN;let v=0,cr=0;
        for(let dy=-hl;dy<=hl;dy++){const pr=(py+dy)*w,cR=(cy+dy)*w;for(let dx=-hl;dx<=hl;dx++){const a=prev[pr+px+dx]-rm,b=curr[cR+cx+dx]-m;cr+=a*b;v+=b*b;}}
        const d=Math.sqrt(v/pN);if(d<3)continue;const ncc=cr/(pN*rd*d);if(ncc>bn){bn=ncc;bx=cx;by=cy;}
      }
      if(bn>.3){
        const rx0=Math.max(hl+1,bx-2),rx1=Math.min(w-hl-2,bx+2),ry0=Math.max(hl+1,by-2),ry1=Math.min(h-hl-2,by+2);
        for(let cy=ry0;cy<=ry1;cy++)for(let cx=rx0;cx<=rx1;cx++){
          let s=0;for(let dy=-hl;dy<=hl;dy++){const r=(cy+dy)*w;for(let dx=-hl;dx<=hl;dx++)s+=curr[r+cx+dx];}
          const m=s/pN;let v=0,cr=0;
          for(let dy=-hl;dy<=hl;dy++){const pr=(py+dy)*w,cR=(cy+dy)*w;for(let dx=-hl;dx<=hl;dx++){const a=prev[pr+px+dx]-rm,b=curr[cR+cx+dx]-m;cr+=a*b;v+=b*b;}}
          const d=Math.sqrt(v/pN);if(d<3)continue;const ncc=cr/(pN*rd*d);if(ncc>bn){bn=ncc;bx=cx;by=cy;}
        }
      }
      if(bn>=C.nccTh)tracked.push({x:bx,y:by,px:f.x,py:f.y,dx:bx-f.x,dy:by-f.y});
    }
    return tracked;
  }
}

// ========== CAMERA (Sensor Fusion) ==========
// This is the key difference: camera state comes from device sensors
// with visual flow as correction, not the other way around.
class Camera {
  constructor(){
    this.pitch=0;this.yaw=0;this.roll=0;    // Radians from sensors
    this.tx=0;this.ty=-C.cameraHeight;this.tz=0; // World position (Y is up, camera starts above ground)
    this.hasGyro=false;
    this.gyroPitch=0;this.gyroYaw=0;this.gyroRoll=0;
    this.gyroBase=null; // Initial orientation to zero-out
    // Visual odometry accumulators
    this.vtx=0;this.vtz=0;
  }
  setGyro(alpha,beta,gamma){
    // beta = pitch (tilt forward/back), gamma = roll, alpha = compass
    const b=(beta||0)*Math.PI/180;
    const g=(gamma||0)*Math.PI/180;
    const a=(alpha||0)*Math.PI/180;
    if(!this.gyroBase){
      this.gyroBase={a,b,g};
    }
    this.gyroPitch=b-this.gyroBase.b;
    this.gyroYaw=-(a-this.gyroBase.a);
    this.gyroRoll=g-this.gyroBase.g;
    this.hasGyro=true;
  }
  updateFromFlow(tracked){
    if(tracked.length<3)return;
    const n=tracked.length;
    const dxs=new Float32Array(n),dys=new Float32Array(n);
    for(let i=0;i<n;i++){dxs[i]=tracked[i].dx;dys[i]=tracked[i].dy;}
    dxs.sort();dys.sort();
    const m=n>>1,mdx=dxs[m],mdy=dys[m];
    let ax=0,ay=0,c=0;
    for(let i=0;i<n;i++){
      const t=tracked[i];
      if(Math.abs(t.dx-mdx)>4&&Math.abs(t.dy-mdy)>4)continue;
      ax+=t.dx;ay+=t.dy;c++;
    }
    if(c<2)return;
    ax/=c;ay/=c;
    // Visual rotation estimate
    const vYaw=ax*0.001;
    const vPitch=-ay*0.001;
    // Visual translation estimate (small)
    this.vtx+=ax*0.0003;
    this.vtz+=ay*0.0003;

    if(this.hasGyro){
      // Sensor fusion: gyro is primary, visual is small correction
      this.pitch=this.gyroPitch;
      this.yaw=this.gyroYaw;
      this.roll=this.gyroRoll;
      // Add visual translation on top
      this.tx=this.vtx;
      this.tz=this.vtz;
    } else {
      // No gyro: use visual only (desktop fallback)
      this.yaw+=vYaw;
      this.pitch+=vPitch;
      this.tx=this.vtx;
      this.tz=this.vtz;
    }
    this.ty=-C.cameraHeight; // Always at camera height above ground
  }
  // Build view matrix components
  getViewParams(){
    return {
      pitch:this.pitch, yaw:this.yaw, roll:this.roll,
      tx:this.tx, ty:this.ty, tz:this.tz,
    };
  }
  reset(){
    this.pitch=0;this.yaw=0;this.roll=0;
    this.tx=0;this.ty=-C.cameraHeight;this.tz=0;
    this.vtx=0;this.vtz=0;
    this.gyroBase=null;this.hasGyro=false;
  }
}

// ========== GROUND PLANE ==========
// Plane is always at Y=0 in world space. We track confidence
// based on feature quality to decide when to show it.
class Ground {
  constructor(){this.reset();}
  reset(){this.conf=0;this.ready=false;}
  update(feats,tracked){
    // Confidence goes up when we see enough features and they track well
    const fOk=feats.length>=10;
    const tOk=tracked.length>=4;
    const ratio=feats.length>0?tracked.length/feats.length:0;
    if(fOk&&tOk&&ratio>0.2){
      this.conf=Math.min(this.conf+3,100);
    } else if(fOk){
      this.conf=Math.min(this.conf+1,100);
    } else {
      this.conf=Math.max(this.conf-2,0);
    }
    if(this.conf>=40&&!this.ready)this.ready=true;
  }
}

// ========== RENDERER ==========
class Renderer {
  constructor(canvas){
    this.c=canvas;this.ctx=canvas.getContext('2d');
    this.objs=[];this.debug=false;
    this.cols=[
      {f:'#00e5a0',t:'#4dffc8',r:'#00b87e',s:'rgba(0,0,0,0.18)'},
      {f:'#00b8ff',t:'#66d4ff',r:'#0090cc',s:'rgba(0,0,0,0.18)'},
      {f:'#a855f7',t:'#c084fc',r:'#8630d9',s:'rgba(0,0,0,0.18)'},
      {f:'#ff6b35',t:'#ff9466',r:'#cc5228',s:'rgba(0,0,0,0.18)'},
      {f:'#eab308',t:'#fcd34d',r:'#b88e06',s:'rgba(0,0,0,0.18)'},
    ];
    this.fovY=60*Math.PI/180; // 60° vertical FOV
  }

  // Project world point to screen using proper perspective camera
  proj(wx,wy,wz,cam,sw,sh){
    // Translate to camera space
    let x=wx-cam.tx, y=wy-cam.ty, z=wz-cam.tz;
    // Rotate by yaw (Y axis)
    const cy=Math.cos(-cam.yaw),sy=Math.sin(-cam.yaw);
    let x1=x*cy+z*sy, z1=-x*sy+z*cy;
    // Rotate by pitch (X axis)
    const cp=Math.cos(-cam.pitch),sp=Math.sin(-cam.pitch);
    let y1=y*cp-z1*sp, z2=y*sp+z1*cp;
    if(z2<0.01)return null;
    // Perspective divide
    const f=sh/(2*Math.tan(this.fovY/2));
    const sx=x1*f/z2+sw/2;
    const sy2=-y1*f/z2+sh/2;  // Flip Y (screen Y goes down)
    return{x:sx,y:sy2,z:z2,sc:f/z2};
  }

  // Place object on ground plane at tap position
  placeObj(tapX,tapY,sw,sh,cam){
    if(this.objs.length>=C.maxObj)return false;
    // Ray from camera through tap point onto ground (Y=0)
    const f=sh/(2*Math.tan(this.fovY/2));
    // Screen to camera-local ray direction
    const rdx=(tapX-sw/2)/f;
    const rdy=-(tapY-sh/2)/f;
    const rdz=1;
    // Rotate ray by camera orientation
    const cp=Math.cos(cam.pitch),sp=Math.sin(cam.pitch);
    const cy=Math.cos(cam.yaw),sy=Math.sin(cam.yaw);
    // Pitch first
    let ry=rdy*cp+rdz*sp;
    let rz=-rdy*sp+rdz*cp;
    let rx=rdx;
    // Then yaw
    let rx2=rx*cy-rz*sy;
    let rz2=rx*sy+rz*cy;
    // Ray: origin=cam.pos, dir=(rx2,ry,rz2)
    // Ground plane: y=0
    // t = (0 - cam.ty) / ry
    if(Math.abs(ry)<0.001)return false;
    const t=(0-cam.ty)/ry;
    if(t<0.1||t>50)return false; // Behind camera or too far
    const wx=cam.tx+rx2*t;
    const wz=cam.tz+rz2*t;

    this.objs.push({
      wx, wy:0, wz,  // World position ON the ground
      ci:(Math.random()*this.cols.length)|0,
      t0:performance.now(), rot:Math.random()*6.28, as:0, us:1.0
    });
    return true;
  }

  drawGround(cam,sw,sh){
    const ctx=this.ctx;
    // Draw grid on Y=0 plane
    ctx.strokeStyle='rgba(0,229,160,0.07)';
    ctx.lineWidth=0.8;
    ctx.beginPath();
    const gs=0.3, range=6; // Grid spacing and range in meters
    for(let i=-range;i<=range;i++){
      const v=i*gs;
      const p1=this.proj(v,0,-range*gs,cam,sw,sh);
      const p2=this.proj(v,0,range*gs,cam,sw,sh);
      if(p1&&p2&&p1.z>0&&p2.z>0){ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);}
      const p3=this.proj(-range*gs,0,v,cam,sw,sh);
      const p4=this.proj(range*gs,0,v,cam,sw,sh);
      if(p3&&p4&&p3.z>0&&p4.z>0){ctx.moveTo(p3.x,p3.y);ctx.lineTo(p4.x,p4.y);}
    }
    ctx.stroke();
  }

  drawCubes(cam,sw,sh){
    const ctx=this.ctx,now=performance.now();
    // Sort by distance
    const sorted=this.objs.map((o,i)=>({o,d:(o.wx-cam.tx)**2+(o.wz-cam.tz)**2})).sort((a,b)=>b.d-a.d);
    for(const{o}of sorted){
      const p=this.proj(o.wx,o.wy,o.wz,cam,sw,sh);
      if(!p||p.z<0.05)continue;
      const age=(now-o.t0)*0.003;
      o.as=age<1?age*age*(3-2*age):1;
      o.rot+=0.012;
      const worldSize=C.cubeWorldSize*o.us;
      const s=worldSize*p.sc*o.as;
      if(s<0.5||p.x<-80||p.x>sw+80||p.y<-80||p.y>sh+80)continue;
      const c=this.cols[o.ci],h=s*0.5,off=h*0.35;
      const rs=Math.sin(o.rot)*s*0.06;
      ctx.save();ctx.translate(p.x,p.y);ctx.globalAlpha=Math.min(1,o.as);
      // Shadow on ground
      ctx.fillStyle=c.s;ctx.beginPath();ctx.ellipse(0,h+1,s*0.5,s*0.1,0,0,6.28);ctx.fill();
      // Cube faces
      ctx.fillStyle=c.t;ctx.beginPath();ctx.moveTo(-h+rs,-h);ctx.lineTo(-h+off+rs,-h-off);ctx.lineTo(h+off+rs,-h-off);ctx.lineTo(h+rs,-h);ctx.closePath();ctx.fill();
      ctx.fillStyle=c.f;ctx.fillRect(-h+rs,-h,s,s);
      ctx.fillStyle=c.r;ctx.beginPath();ctx.moveTo(h+rs,-h);ctx.lineTo(h+off+rs,-h-off);ctx.lineTo(h+off+rs,h-off);ctx.lineTo(h+rs,h);ctx.closePath();ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.08)';ctx.lineWidth=.5;ctx.strokeRect(-h+rs,-h,s,s);
      ctx.restore();
    }
  }

  drawFeats(feats,tracked,sw,sh){
    const ctx=this.ctx,sx=sw/C.pw,sy=sh/C.ph;
    ctx.fillStyle='rgba(0,229,160,.6)';
    for(const f of feats)ctx.fillRect(f.x*sx-1.5,f.y*sy-1.5,3,3);
    if(tracked.length){
      ctx.strokeStyle='rgba(0,184,255,.5)';ctx.lineWidth=1;ctx.beginPath();
      for(const t of tracked){ctx.moveTo(t.px*sx,t.py*sy);ctx.lineTo(t.x*sx,t.y*sy);}
      ctx.stroke();
    }
  }
}

// ========== MAIN ==========
class App {
  constructor(){
    this.vid=document.getElementById('videoEl');
    this.cvs=document.getElementById('arCanvas');
    this.ctx=this.cvs.getContext('2d');
    this.off=document.createElement('canvas');this.off.width=C.pw;this.off.height=C.ph;
    this.offCtx=this.off.getContext('2d',{willReadFrequently:true});
    this.ip=new ImgProc(C.pw,C.ph);
    this.harris=new Harris(this.ip);
    this.flow=new Flow(this.ip);
    this.cam=new Camera();
    this.gnd=new Ground();
    this.ren=new Renderer(this.cvs);
    this.prevF=[];this.curF=[];this.tracked=[];
    this.on=false;this.fc=0;this.sc=0;this.fps=0;this.fpsT=0;this.fpsC=0;this.uiT=0;this.ms=0;
    this._shown=false;
    // Pinch
    this._pinch=false;this._pinchD0=0;this._pinchS0=1;this._pinchObj=null;
    this._tapT=0;this._moved=false;this._shTimer=null;
    // DOM
    this.$={};
    ['stxt','fps','dbg','dF','dT','dC','dP','dPY','dG','dM','objN','scaleHint','toast'].forEach(
      id=>this.$[id]=document.getElementById(id));
    this.$.pill=document.getElementById('pill');
    this.$.reticle=document.getElementById('reticle');
    this.$.objBadge=document.getElementById('objBadge');
    this._bind();
  }
  _bind(){
    document.getElementById('startBtn').onclick=()=>this.start();
    document.getElementById('bDbg').onclick=()=>{this.ren.debug=!this.ren.debug;document.getElementById('dbg').classList.toggle('show');document.getElementById('bDbg').classList.toggle('on');};
    document.getElementById('bCal').onclick=()=>this._cal();
    document.getElementById('bRst').onclick=()=>this._reset();
    // Touch
    this.cvs.addEventListener('touchstart',e=>{
      e.preventDefault();
      if(e.touches.length===2){
        this._pinch=true;this._moved=true;
        this._pinchD0=this._td(e.touches[0],e.touches[1]);
        this._pinchObj=this.ren.objs.length?this.ren.objs[this.ren.objs.length-1]:null;
        if(this._pinchObj)this._pinchS0=this._pinchObj.us;
        this._sh();
      }else if(e.touches.length===1){this._tapT=performance.now();this._moved=false;this._pinch=false;}
    },{passive:false});
    this.cvs.addEventListener('touchmove',e=>{
      e.preventDefault();
      if(e.touches.length===2&&this._pinchObj){
        this._pinch=true;this._moved=true;
        const d=this._td(e.touches[0],e.touches[1]);
        this._pinchObj.us=Math.max(0.1,Math.min(30,this._pinchS0*(d/this._pinchD0)));
        this._sh();
      }else if(e.touches.length===1)this._moved=true;
    },{passive:false});
    this.cvs.addEventListener('touchend',e=>{
      e.preventDefault();
      if(e.touches.length===0){
        if(!this._pinch&&!this._moved&&(performance.now()-this._tapT)<300){
          const t=e.changedTouches[0];this._tap(t.clientX,t.clientY);
        }
        this._pinch=false;this._pinchObj=null;
        if(this._shTimer)clearTimeout(this._shTimer);
        this._shTimer=setTimeout(()=>this.$.scaleHint.classList.remove('show'),800);
      }
    },{passive:false});
    this.cvs.addEventListener('click',e=>this._tap(e.clientX,e.clientY));
    this.cvs.addEventListener('wheel',e=>{
      e.preventDefault();
      if(!this.ren.objs.length)return;
      const o=this.ren.objs[this.ren.objs.length-1];
      o.us=Math.max(0.1,Math.min(30,o.us*(e.deltaY>0?.9:1.1)));
      this._sh();
      if(this._shTimer)clearTimeout(this._shTimer);
      this._shTimer=setTimeout(()=>this.$.scaleHint.classList.remove('show'),800);
    },{passive:false});
    window.addEventListener('resize',()=>this._rsz());
    // Gyro
    if(window.DeviceOrientationEvent){
      if(typeof DeviceOrientationEvent.requestPermission==='function'){
        document.getElementById('startBtn').addEventListener('click',()=>{
          DeviceOrientationEvent.requestPermission().then(r=>{if(r==='granted')this._gy();}).catch(()=>{});
        },{once:true});
      }else this._gy();
    }
  }
  _gy(){window.addEventListener('deviceorientation',e=>{if(e.alpha!==null)this.cam.setGyro(e.alpha,e.beta,e.gamma);});}
  _td(a,b){const dx=a.clientX-b.clientX,dy=a.clientY-b.clientY;return Math.sqrt(dx*dx+dy*dy);}
  _sh(){
    const o=this._pinchObj||(this.ren.objs.length?this.ren.objs[this.ren.objs.length-1]:null);
    if(!o)return;
    this.$.scaleHint.textContent='Escala: '+o.us.toFixed(1)+'×';
    this.$.scaleHint.classList.add('show');
  }
  _toast(msg){this.$.toast.textContent=msg;this.$.toast.classList.add('show');setTimeout(()=>this.$.toast.classList.remove('show'),2200);}
  async start(){
    try{
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment',width:{ideal:640},height:{ideal:480}}});
      this.vid.srcObject=s;await this.vid.play();
      document.getElementById('startScreen').classList.add('hidden');
      this._rsz();this.on=true;
      this.$.stxt.textContent='Escaneando superfície...';
      this._toast('Mova a câmera lentamente');
      this.fpsT=performance.now();this._loop();
    }catch(e){alert('Câmera: '+e.message);}
  }
  _rsz(){
    const dp=Math.min(devicePixelRatio||1,2),w=innerWidth,h=innerHeight;
    this.cvs.width=w*dp;this.cvs.height=h*dp;
    this.cvs.style.width=w+'px';this.cvs.style.height=h+'px';
    this.ctx.setTransform(dp,0,0,dp,0,0);
    this.sw=w;this.sh=h;
  }
  _cal(){
    const b=document.getElementById('bCal');b.textContent='...';b.classList.add('on');
    if(this.curF.length<10)C.harrisTh=Math.max(500,C.harrisTh*.6);
    else if(this.curF.length>60)C.harrisTh=Math.min(50000,C.harrisTh*1.5);
    this.cam.gyroBase=null; // Re-zero gyro
    setTimeout(()=>{b.textContent='Calibrar';b.classList.remove('on');},1000);
    this._toast('Calibrado');
  }
  _reset(){
    this.prevF=[];this.curF=[];this.tracked=[];
    this.cam.reset();this.gnd.reset();this.ren.objs=[];
    this.fc=0;this.sc=0;this._shown=false;this.ip.n=0;
    C.harrisTh=5000;
    this.$.pill.classList.remove('ok');
    this.$.stxt.textContent='Escaneando superfície...';
    this.$.reticle.classList.remove('show');
    this.$.objBadge.style.display='none';
    this._toast('Reset completo');
  }
  _tap(cx,cy){
    if(!this.gnd.ready)return;
    const r=this.cvs.getBoundingClientRect();
    const v=this.cam.getViewParams();
    if(this.ren.placeObj(cx-r.left,cy-r.top,this.sw,this.sh,v)){
      this.$.objBadge.style.display='block';
      this.$.objN.textContent=this.ren.objs.length;
    }
  }
  _loop(){
    if(!this.on)return;
    const t0=performance.now();
    this.fpsC++;
    if(t0-this.fpsT>=1000){this.fps=this.fpsC;this.fpsC=0;this.fpsT=t0;this.$.fps.textContent=this.fps+' FPS';}
    this.ctx.drawImage(this.vid,0,0,this.sw,this.sh);
    if(this.fc%C.slamEvery===0)this._slam();
    const v=this.cam.getViewParams();
    if(this.gnd.ready){
      this.ren.drawGround(v,this.sw,this.sh);
    }
    this.ren.drawCubes(v,this.sw,this.sh);
    if(this.ren.debug)this.ren.drawFeats(this.curF,this.tracked,this.sw,this.sh);
    if(t0-this.uiT>C.uiMs){this.uiT=t0;this._ui();}
    this.ms=performance.now()-t0;this.fc++;
    requestAnimationFrame(()=>this._loop());
  }
  _slam(){
    this.offCtx.drawImage(this.vid,0,0,C.pw,C.ph);
    const d=this.offCtx.getImageData(0,0,C.pw,C.ph);
    this.ip.capture(d.data);this.ip.grads();this.sc++;
    if(this.sc<2){this.curF=this.harris.detect();this.prevF=this.curF;return;}
    this.tracked=this.prevF.length?this.flow.track(this.prevF):[];
    this.cam.updateFromFlow(this.tracked);
    this.gnd.update(this.curF,this.tracked);
    this.curF=this.harris.detect();
    this.prevF=this.curF;
  }
  _ui(){
    if(this.gnd.ready){
      if(!this._shown){
        this._shown=true;
        this.$.pill.classList.add('ok');
        this.$.stxt.textContent='Toque para colocar cubos';
        this.$.reticle.classList.add('show');
        this._toast('✦ Plano detectado');
      }
    }else{
      this.$.stxt.textContent='Escaneando... '+(this.gnd.conf|0)+'%';
    }
    if(this.ren.debug){
      this.$.dF.textContent=this.curF.length;
      this.$.dT.textContent=this.tracked.length;
      const v=this.cam.getViewParams();
      this.$.dC.textContent=v.pitch.toFixed(2)+','+v.yaw.toFixed(2);
      this.$.dP.textContent=this.gnd.ready?'YES':this.gnd.conf+'%';
      this.$.dPY.textContent='Y=0 h='+C.cameraHeight+'m';
      this.$.dG.textContent=this.cam.hasGyro?'ON':'OFF';
      this.$.dM.textContent=this.ms.toFixed(1)+'ms';
    }
  }
}
new App();
</script>
</body>
</html>
